// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sat, 20 Nov 2021 18:13:09 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package hackrf

/*
#cgo CFLAGS: -msse4.1 -Wall -fPIC -I. -I.. -I../host/libhackrf/src
#cgo LDFLAGS: -lm -lusb-1.0 ${SRCDIR}/../host/build/libhackrf/src/libhackrf.a
#include <inttypes.h>
#include <complex.h>
#include "host/libhackrf/src/hackrf.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
// import "C"
// import (
// 	"runtime"
// 	"sync"
// 	"unsafe"
// )

// // Ref returns a reference to C object as it is.
// func (x *Device) Ref() *C.hackrf_device {
// 	if x == nil {
// 		return nil
// 	}
// 	return (*C.hackrf_device)(unsafe.Pointer(x))
// }

// // Free cleanups the referenced memory using C free.
// func (x *Device) Free() {
// 	if x != nil {
// 		C.free(unsafe.Pointer(x))
// 	}
// }

// // NewDeviceRef converts the C object reference into a raw struct reference without wrapping.
// func NewDeviceRef(ref unsafe.Pointer) *Device {
// 	return (*Device)(ref)
// }

// // NewDevice allocates a new C object of this type and converts the reference into
// // a raw struct reference without wrapping.
// func NewDevice() *Device {
// 	return (*Device)(allocDeviceMemory(1))
// }

// // allocDeviceMemory allocates memory for type C.hackrf_device in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocDeviceMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceValue))
// 	if err != nil {
// 		panic("memory alloc error: " + err.Error())
// 	}
// 	return mem
// }

// const sizeOfDeviceValue = unsafe.Sizeof([1]C.hackrf_device{})

// // cgoAllocMap stores pointers to C allocated memory for future reference.
// type cgoAllocMap struct {
// 	mux sync.RWMutex
// 	m   map[unsafe.Pointer]struct{}
// }

// var cgoAllocsUnknown = new(cgoAllocMap)

// func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
// 	a.mux.Lock()
// 	if a.m == nil {
// 		a.m = make(map[unsafe.Pointer]struct{})
// 	}
// 	a.m[ptr] = struct{}{}
// 	a.mux.Unlock()
// }

// func (a *cgoAllocMap) IsEmpty() bool {
// 	a.mux.RLock()
// 	isEmpty := len(a.m) == 0
// 	a.mux.RUnlock()
// 	return isEmpty
// }

// func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
// 	if b == nil || b.IsEmpty() {
// 		return
// 	}
// 	b.mux.Lock()
// 	a.mux.Lock()
// 	for ptr := range b.m {
// 		if a.m == nil {
// 			a.m = make(map[unsafe.Pointer]struct{})
// 		}
// 		a.m[ptr] = struct{}{}
// 		delete(b.m, ptr)
// 	}
// 	a.mux.Unlock()
// 	b.mux.Unlock()
// }

// func (a *cgoAllocMap) Free() {
// 	a.mux.Lock()
// 	for ptr := range a.m {
// 		C.free(ptr)
// 		delete(a.m, ptr)
// 	}
// 	a.mux.Unlock()
// }

// // PassRef returns a reference to C object as it is or allocates a new C object of this type.
// func (x *Device) PassRef() *C.hackrf_device {
// 	if x == nil {
// 		x = (*Device)(allocDeviceMemory(1))
// 	}
// 	return (*C.hackrf_device)(unsafe.Pointer(x))
// }

// // allocTransferMemory allocates memory for type C.hackrf_transfer in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocTransferMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTransferValue))
// 	if err != nil {
// 		panic("memory alloc error: " + err.Error())
// 	}
// 	return mem
// }

// const sizeOfTransferValue = unsafe.Sizeof([1]C.hackrf_transfer{})

// type sliceHeader struct {
// 	Data unsafe.Pointer
// 	Len  int
// 	Cap  int
// }

// // Ref returns the underlying reference to C object or nil if struct is nil.
// func (x *Transfer) Ref() *C.hackrf_transfer {
// 	if x == nil {
// 		return nil
// 	}
// 	return x.ref5305f741
// }

// // Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// // Does nothing if struct is nil or has no allocation map.
// func (x *Transfer) Free() {
// 	if x != nil && x.allocs5305f741 != nil {
// 		x.allocs5305f741.(*cgoAllocMap).Free()
// 		x.ref5305f741 = nil
// 	}
// }

// // NewTransferRef creates a new wrapper struct with underlying reference set to the original C object.
// // Returns nil if the provided pointer to C object is nil too.
// func NewTransferRef(ref unsafe.Pointer) *Transfer {
// 	if ref == nil {
// 		return nil
// 	}
// 	obj := new(Transfer)
// 	obj.ref5305f741 = (*C.hackrf_transfer)(unsafe.Pointer(ref))
// 	return obj
// }

// // PassRef returns the underlying C object, otherwise it will allocate one and set its values
// // from this wrapping struct, counting allocations into an allocation map.
// func (x *Transfer) PassRef() (*C.hackrf_transfer, *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	} else if x.ref5305f741 != nil {
// 		return x.ref5305f741, nil
// 	}
// 	mem5305f741 := allocTransferMemory(1)
// 	ref5305f741 := (*C.hackrf_transfer)(mem5305f741)
// 	allocs5305f741 := new(cgoAllocMap)
// 	allocs5305f741.Add(mem5305f741)

// 	var cdevice_allocs *cgoAllocMap
// 	ref5305f741.device, cdevice_allocs = (*C.hackrf_device)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Device)).Data)), cgoAllocsUnknown
// 	allocs5305f741.Borrow(cdevice_allocs)

// 	var cbuffer_allocs *cgoAllocMap
// 	ref5305f741.buffer, cbuffer_allocs = (*C.uint8_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Buffer)).Data)), cgoAllocsUnknown
// 	allocs5305f741.Borrow(cbuffer_allocs)

// 	var cbuffer_length_allocs *cgoAllocMap
// 	ref5305f741.buffer_length, cbuffer_length_allocs = (C.int)(x.BufferLength), cgoAllocsUnknown
// 	allocs5305f741.Borrow(cbuffer_length_allocs)

// 	var cvalid_length_allocs *cgoAllocMap
// 	ref5305f741.valid_length, cvalid_length_allocs = (C.int)(x.ValidLength), cgoAllocsUnknown
// 	allocs5305f741.Borrow(cvalid_length_allocs)

// 	var crx_ctx_allocs *cgoAllocMap
// 	ref5305f741.rx_ctx, crx_ctx_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.RxCtx)), cgoAllocsUnknown
// 	allocs5305f741.Borrow(crx_ctx_allocs)

// 	var ctx_ctx_allocs *cgoAllocMap
// 	ref5305f741.tx_ctx, ctx_ctx_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.TxCtx)), cgoAllocsUnknown
// 	allocs5305f741.Borrow(ctx_ctx_allocs)

// 	x.ref5305f741 = ref5305f741
// 	x.allocs5305f741 = allocs5305f741
// 	return ref5305f741, allocs5305f741

// }

// // PassValue does the same as PassRef except that it will try to dereference the returned pointer.
// func (x Transfer) PassValue() (C.hackrf_transfer, *cgoAllocMap) {
// 	if x.ref5305f741 != nil {
// 		return *x.ref5305f741, nil
// 	}
// 	ref, allocs := x.PassRef()
// 	return *ref, allocs
// }

// // Deref uses the underlying reference to C object and fills the wrapping struct with values.
// // Do not forget to call this method whether you get a struct for C object and want to read its values.
// func (x *Transfer) Deref() {
// 	if x.ref5305f741 == nil {
// 		return
// 	}
// 	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Device))
// 	hxfc4425b.Data = unsafe.Pointer(x.ref5305f741.device)
// 	hxfc4425b.Cap = 0x7fffffff
// 	// hxfc4425b.Len = ?

// 	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Buffer))
// 	hxf95e7c8.Data = unsafe.Pointer(x.ref5305f741.buffer)
// 	hxf95e7c8.Cap = 0x7fffffff
// 	// hxf95e7c8.Len = ?

// 	x.BufferLength = (int32)(x.ref5305f741.buffer_length)
// 	x.ValidLength = (int32)(x.ref5305f741.valid_length)
// 	x.RxCtx = (unsafe.Pointer)(unsafe.Pointer(x.ref5305f741.rx_ctx))
// 	x.TxCtx = (unsafe.Pointer)(unsafe.Pointer(x.ref5305f741.tx_ctx))
// }

// // allocReadPartidSerialnoMemory allocates memory for type C.read_partid_serialno_t in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocReadPartidSerialnoMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfReadPartidSerialnoValue))
// 	if err != nil {
// 		panic("memory alloc error: " + err.Error())
// 	}
// 	return mem
// }

// const sizeOfReadPartidSerialnoValue = unsafe.Sizeof([1]C.read_partid_serialno_t{})

// // Ref returns the underlying reference to C object or nil if struct is nil.
// func (x *ReadPartidSerialno) Ref() *C.read_partid_serialno_t {
// 	if x == nil {
// 		return nil
// 	}
// 	return x.ref58f14812
// }

// // Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// // Does nothing if struct is nil or has no allocation map.
// func (x *ReadPartidSerialno) Free() {
// 	if x != nil && x.allocs58f14812 != nil {
// 		x.allocs58f14812.(*cgoAllocMap).Free()
// 		x.ref58f14812 = nil
// 	}
// }

// // NewReadPartidSerialnoRef creates a new wrapper struct with underlying reference set to the original C object.
// // Returns nil if the provided pointer to C object is nil too.
// func NewReadPartidSerialnoRef(ref unsafe.Pointer) *ReadPartidSerialno {
// 	if ref == nil {
// 		return nil
// 	}
// 	obj := new(ReadPartidSerialno)
// 	obj.ref58f14812 = (*C.read_partid_serialno_t)(unsafe.Pointer(ref))
// 	return obj
// }

// // PassRef returns the underlying C object, otherwise it will allocate one and set its values
// // from this wrapping struct, counting allocations into an allocation map.
// func (x *ReadPartidSerialno) PassRef() (*C.read_partid_serialno_t, *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	} else if x.ref58f14812 != nil {
// 		return x.ref58f14812, nil
// 	}
// 	mem58f14812 := allocReadPartidSerialnoMemory(1)
// 	ref58f14812 := (*C.read_partid_serialno_t)(mem58f14812)
// 	allocs58f14812 := new(cgoAllocMap)
// 	allocs58f14812.Add(mem58f14812)

// 	var cpart_id_allocs *cgoAllocMap
// 	ref58f14812.part_id, cpart_id_allocs = *(*[2]C.uint32_t)(unsafe.Pointer(&x.PartId)), cgoAllocsUnknown
// 	allocs58f14812.Borrow(cpart_id_allocs)

// 	var cserial_no_allocs *cgoAllocMap
// 	ref58f14812.serial_no, cserial_no_allocs = *(*[4]C.uint32_t)(unsafe.Pointer(&x.SerialNo)), cgoAllocsUnknown
// 	allocs58f14812.Borrow(cserial_no_allocs)

// 	x.ref58f14812 = ref58f14812
// 	x.allocs58f14812 = allocs58f14812
// 	return ref58f14812, allocs58f14812

// }

// // PassValue does the same as PassRef except that it will try to dereference the returned pointer.
// func (x ReadPartidSerialno) PassValue() (C.read_partid_serialno_t, *cgoAllocMap) {
// 	if x.ref58f14812 != nil {
// 		return *x.ref58f14812, nil
// 	}
// 	ref, allocs := x.PassRef()
// 	return *ref, allocs
// }

// // Deref uses the underlying reference to C object and fills the wrapping struct with values.
// // Do not forget to call this method whether you get a struct for C object and want to read its values.
// func (x *ReadPartidSerialno) Deref() {
// 	if x.ref58f14812 == nil {
// 		return
// 	}
// 	x.PartId = *(*[2]uint32)(unsafe.Pointer(&x.ref58f14812.part_id))
// 	x.SerialNo = *(*[4]uint32)(unsafe.Pointer(&x.ref58f14812.serial_no))
// }

// // allocOperacakeDwellTimeMemory allocates memory for type C.hackrf_operacake_dwell_time in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocOperacakeDwellTimeMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOperacakeDwellTimeValue))
// 	if err != nil {
// 		panic("memory alloc error: " + err.Error())
// 	}
// 	return mem
// }

// const sizeOfOperacakeDwellTimeValue = unsafe.Sizeof([1]C.hackrf_operacake_dwell_time{})

// // Ref returns the underlying reference to C object or nil if struct is nil.
// func (x *OperacakeDwellTime) Ref() *C.hackrf_operacake_dwell_time {
// 	if x == nil {
// 		return nil
// 	}
// 	return x.refc2030ff1
// }

// // Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// // Does nothing if struct is nil or has no allocation map.
// func (x *OperacakeDwellTime) Free() {
// 	if x != nil && x.allocsc2030ff1 != nil {
// 		x.allocsc2030ff1.(*cgoAllocMap).Free()
// 		x.refc2030ff1 = nil
// 	}
// }

// // NewOperacakeDwellTimeRef creates a new wrapper struct with underlying reference set to the original C object.
// // Returns nil if the provided pointer to C object is nil too.
// func NewOperacakeDwellTimeRef(ref unsafe.Pointer) *OperacakeDwellTime {
// 	if ref == nil {
// 		return nil
// 	}
// 	obj := new(OperacakeDwellTime)
// 	obj.refc2030ff1 = (*C.hackrf_operacake_dwell_time)(unsafe.Pointer(ref))
// 	return obj
// }

// // PassRef returns the underlying C object, otherwise it will allocate one and set its values
// // from this wrapping struct, counting allocations into an allocation map.
// func (x *OperacakeDwellTime) PassRef() (*C.hackrf_operacake_dwell_time, *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	} else if x.refc2030ff1 != nil {
// 		return x.refc2030ff1, nil
// 	}
// 	memc2030ff1 := allocOperacakeDwellTimeMemory(1)
// 	refc2030ff1 := (*C.hackrf_operacake_dwell_time)(memc2030ff1)
// 	allocsc2030ff1 := new(cgoAllocMap)
// 	allocsc2030ff1.Add(memc2030ff1)

// 	var cdwell_allocs *cgoAllocMap
// 	refc2030ff1.dwell, cdwell_allocs = (C.uint32_t)(x.Dwell), cgoAllocsUnknown
// 	allocsc2030ff1.Borrow(cdwell_allocs)

// 	var cport_allocs *cgoAllocMap
// 	refc2030ff1.port, cport_allocs = (C.uint8_t)(x.Port), cgoAllocsUnknown
// 	allocsc2030ff1.Borrow(cport_allocs)

// 	x.refc2030ff1 = refc2030ff1
// 	x.allocsc2030ff1 = allocsc2030ff1
// 	return refc2030ff1, allocsc2030ff1

// }

// // PassValue does the same as PassRef except that it will try to dereference the returned pointer.
// func (x OperacakeDwellTime) PassValue() (C.hackrf_operacake_dwell_time, *cgoAllocMap) {
// 	if x.refc2030ff1 != nil {
// 		return *x.refc2030ff1, nil
// 	}
// 	ref, allocs := x.PassRef()
// 	return *ref, allocs
// }

// // Deref uses the underlying reference to C object and fills the wrapping struct with values.
// // Do not forget to call this method whether you get a struct for C object and want to read its values.
// func (x *OperacakeDwellTime) Deref() {
// 	if x.refc2030ff1 == nil {
// 		return
// 	}
// 	x.Dwell = (uint32)(x.refc2030ff1.dwell)
// 	x.Port = (byte)(x.refc2030ff1.port)
// }

// // allocOperacakeFreqRangeMemory allocates memory for type C.hackrf_operacake_freq_range in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocOperacakeFreqRangeMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOperacakeFreqRangeValue))
// 	if err != nil {
// 		panic("memory alloc error: " + err.Error())
// 	}
// 	return mem
// }

// const sizeOfOperacakeFreqRangeValue = unsafe.Sizeof([1]C.hackrf_operacake_freq_range{})

// // Ref returns the underlying reference to C object or nil if struct is nil.
// func (x *OperacakeFreqRange) Ref() *C.hackrf_operacake_freq_range {
// 	if x == nil {
// 		return nil
// 	}
// 	return x.refa9b0a099
// }

// // Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// // Does nothing if struct is nil or has no allocation map.
// func (x *OperacakeFreqRange) Free() {
// 	if x != nil && x.allocsa9b0a099 != nil {
// 		x.allocsa9b0a099.(*cgoAllocMap).Free()
// 		x.refa9b0a099 = nil
// 	}
// }

// // NewOperacakeFreqRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// // Returns nil if the provided pointer to C object is nil too.
// func NewOperacakeFreqRangeRef(ref unsafe.Pointer) *OperacakeFreqRange {
// 	if ref == nil {
// 		return nil
// 	}
// 	obj := new(OperacakeFreqRange)
// 	obj.refa9b0a099 = (*C.hackrf_operacake_freq_range)(unsafe.Pointer(ref))
// 	return obj
// }

// // PassRef returns the underlying C object, otherwise it will allocate one and set its values
// // from this wrapping struct, counting allocations into an allocation map.
// func (x *OperacakeFreqRange) PassRef() (*C.hackrf_operacake_freq_range, *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	} else if x.refa9b0a099 != nil {
// 		return x.refa9b0a099, nil
// 	}
// 	mema9b0a099 := allocOperacakeFreqRangeMemory(1)
// 	refa9b0a099 := (*C.hackrf_operacake_freq_range)(mema9b0a099)
// 	allocsa9b0a099 := new(cgoAllocMap)
// 	allocsa9b0a099.Add(mema9b0a099)

// 	var cfreq_min_allocs *cgoAllocMap
// 	refa9b0a099.freq_min, cfreq_min_allocs = (C.uint16_t)(x.FreqMin), cgoAllocsUnknown
// 	allocsa9b0a099.Borrow(cfreq_min_allocs)

// 	var cfreq_max_allocs *cgoAllocMap
// 	refa9b0a099.freq_max, cfreq_max_allocs = (C.uint16_t)(x.FreqMax), cgoAllocsUnknown
// 	allocsa9b0a099.Borrow(cfreq_max_allocs)

// 	var cport_allocs *cgoAllocMap
// 	refa9b0a099.port, cport_allocs = (C.uint8_t)(x.Port), cgoAllocsUnknown
// 	allocsa9b0a099.Borrow(cport_allocs)

// 	x.refa9b0a099 = refa9b0a099
// 	x.allocsa9b0a099 = allocsa9b0a099
// 	return refa9b0a099, allocsa9b0a099

// }

// // PassValue does the same as PassRef except that it will try to dereference the returned pointer.
// func (x OperacakeFreqRange) PassValue() (C.hackrf_operacake_freq_range, *cgoAllocMap) {
// 	if x.refa9b0a099 != nil {
// 		return *x.refa9b0a099, nil
// 	}
// 	ref, allocs := x.PassRef()
// 	return *ref, allocs
// }

// // Deref uses the underlying reference to C object and fills the wrapping struct with values.
// // Do not forget to call this method whether you get a struct for C object and want to read its values.
// func (x *OperacakeFreqRange) Deref() {
// 	if x.refa9b0a099 == nil {
// 		return
// 	}
// 	x.FreqMin = (uint16)(x.refa9b0a099.freq_min)
// 	x.FreqMax = (uint16)(x.refa9b0a099.freq_max)
// 	x.Port = (byte)(x.refa9b0a099.port)
// }

// // allocDeviceListMemory allocates memory for type C.hackrf_device_list_t in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocDeviceListMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceListValue))
// 	if err != nil {
// 		panic("memory alloc error: " + err.Error())
// 	}
// 	return mem
// }

// const sizeOfDeviceListValue = unsafe.Sizeof([1]C.hackrf_device_list_t{})

// // allocPCharMemory allocates memory for type *C.char in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocPCharMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
// 	if err != nil {
// 		panic("memory alloc error: " + err.Error())
// 	}
// 	return mem
// }

// const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// // unpackSSByte transforms a sliced Go data structure into plain C format.
// func unpackSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	}
// 	allocs = new(cgoAllocMap)
// 	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
// 		go allocs.Free()
// 	})

// 	len0 := len(x)
// 	mem0 := allocPCharMemory(len0)
// 	allocs.Add(mem0)
// 	h0 := &sliceHeader{
// 		Data: mem0,
// 		Cap:  len0,
// 		Len:  len0,
// 	}
// 	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
// 	for i0 := range x {
// 		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
// 		v0[i0] = (*C.char)(h.Data)
// 	}
// 	h := (*sliceHeader)(unsafe.Pointer(&v0))
// 	unpacked = (**C.char)(h.Data)
// 	return
// }

// // packSSByte reads sliced Go data structure out from plain C format.
// func packSSByte(v [][]byte, ptr0 **C.char) {
// 	const m = 0x7fffffff
// 	for i0 := range v {
// 		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
// 		hxff2234b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
// 		hxff2234b.Data = unsafe.Pointer(ptr1)
// 		hxff2234b.Cap = 0x7fffffff
// 		// hxff2234b.Len = ?
// 	}
// }

// // Ref returns the underlying reference to C object or nil if struct is nil.
// func (x *DeviceList) Ref() *C.hackrf_device_list_t {
// 	if x == nil {
// 		return nil
// 	}
// 	return x.ref4550fe07
// }

// // Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// // Does nothing if struct is nil or has no allocation map.
// func (x *DeviceList) Free() {
// 	if x != nil && x.allocs4550fe07 != nil {
// 		x.allocs4550fe07.(*cgoAllocMap).Free()
// 		x.ref4550fe07 = nil
// 	}
// }

// // NewDeviceListRef creates a new wrapper struct with underlying reference set to the original C object.
// // Returns nil if the provided pointer to C object is nil too.
// func NewDeviceListRef(ref unsafe.Pointer) *DeviceList {
// 	if ref == nil {
// 		return nil
// 	}
// 	obj := new(DeviceList)
// 	obj.ref4550fe07 = (*C.hackrf_device_list_t)(unsafe.Pointer(ref))
// 	return obj
// }

// // PassRef returns the underlying C object, otherwise it will allocate one and set its values
// // from this wrapping struct, counting allocations into an allocation map.
// func (x *DeviceList) PassRef() (*C.hackrf_device_list_t, *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	} else if x.ref4550fe07 != nil {
// 		return x.ref4550fe07, nil
// 	}
// 	mem4550fe07 := allocDeviceListMemory(1)
// 	ref4550fe07 := (*C.hackrf_device_list_t)(mem4550fe07)
// 	allocs4550fe07 := new(cgoAllocMap)
// 	allocs4550fe07.Add(mem4550fe07)

// 	var cserial_numbers_allocs *cgoAllocMap
// 	ref4550fe07.serial_numbers, cserial_numbers_allocs = unpackSSByte(x.SerialNumbers)
// 	allocs4550fe07.Borrow(cserial_numbers_allocs)

// 	var cusb_board_ids_allocs *cgoAllocMap
// 	ref4550fe07.usb_board_ids, cusb_board_ids_allocs = (*C.enum_hackrf_usb_board_id)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.USBBoardIds)).Data)), cgoAllocsUnknown
// 	allocs4550fe07.Borrow(cusb_board_ids_allocs)

// 	var cusb_device_index_allocs *cgoAllocMap
// 	ref4550fe07.usb_device_index, cusb_device_index_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.USBDeviceIndex)).Data)), cgoAllocsUnknown
// 	allocs4550fe07.Borrow(cusb_device_index_allocs)

// 	var cdevicecount_allocs *cgoAllocMap
// 	ref4550fe07.devicecount, cdevicecount_allocs = (C.int)(x.Devicecount), cgoAllocsUnknown
// 	allocs4550fe07.Borrow(cdevicecount_allocs)

// 	var cusb_devices_allocs *cgoAllocMap
// 	ref4550fe07.usb_devices, cusb_devices_allocs = (*unsafe.Pointer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.USBDevices)).Data)), cgoAllocsUnknown
// 	allocs4550fe07.Borrow(cusb_devices_allocs)

// 	var cusb_devicecount_allocs *cgoAllocMap
// 	ref4550fe07.usb_devicecount, cusb_devicecount_allocs = (C.int)(x.USBDevicecount), cgoAllocsUnknown
// 	allocs4550fe07.Borrow(cusb_devicecount_allocs)

// 	x.ref4550fe07 = ref4550fe07
// 	x.allocs4550fe07 = allocs4550fe07
// 	return ref4550fe07, allocs4550fe07

// }

// // PassValue does the same as PassRef except that it will try to dereference the returned pointer.
// func (x DeviceList) PassValue() (C.hackrf_device_list_t, *cgoAllocMap) {
// 	if x.ref4550fe07 != nil {
// 		return *x.ref4550fe07, nil
// 	}
// 	ref, allocs := x.PassRef()
// 	return *ref, allocs
// }

// // Deref uses the underlying reference to C object and fills the wrapping struct with values.
// // Do not forget to call this method whether you get a struct for C object and want to read its values.
// func (x *DeviceList) Deref() {
// 	if x.ref4550fe07 == nil {
// 		return
// 	}
// 	packSSByte(x.SerialNumbers, x.ref4550fe07.serial_numbers)
// 	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.USBBoardIds))
// 	hxff73280.Data = unsafe.Pointer(x.ref4550fe07.usb_board_ids)
// 	hxff73280.Cap = 0x7fffffff
// 	// hxff73280.Len = ?

// 	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.USBDeviceIndex))
// 	hxfa9955c.Data = unsafe.Pointer(x.ref4550fe07.usb_device_index)
// 	hxfa9955c.Cap = 0x7fffffff
// 	// hxfa9955c.Len = ?

// 	x.Devicecount = (int32)(x.ref4550fe07.devicecount)
// 	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.USBDevices))
// 	hxfa3f05c.Data = unsafe.Pointer(x.ref4550fe07.usb_devices)
// 	hxfa3f05c.Cap = 0x7fffffff
// 	// hxfa3f05c.Len = ?

// 	x.USBDevicecount = (int32)(x.ref4550fe07.usb_devicecount)
// }

// func (x SampleBlockCbFn) PassRef() (ref *C.hackrf_sample_block_cb_fn, allocs *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	}
// 	if sampleBlockCbFn9F964168Func == nil {
// 		sampleBlockCbFn9F964168Func = x
// 	}
// 	return (*C.hackrf_sample_block_cb_fn)(C.hackrf_sample_block_cb_fn_9f964168), nil
// }

// func (x SampleBlockCbFn) PassValue() (ref C.hackrf_sample_block_cb_fn, allocs *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	}
// 	if sampleBlockCbFn9F964168Func == nil {
// 		sampleBlockCbFn9F964168Func = x
// 	}
// 	return (C.hackrf_sample_block_cb_fn)(C.hackrf_sample_block_cb_fn_9f964168), nil
// }

// func NewSampleBlockCbFnRef(ref unsafe.Pointer) *SampleBlockCbFn {
// 	return (*SampleBlockCbFn)(ref)
// }

// //export sampleBlockCbFn9F964168
// func sampleBlockCbFn9F964168(cTransfer *C.hackrf_transfer) C.int {
// 	if sampleBlockCbFn9F964168Func != nil {
// 		Transfer9f964168 := NewTransferRef(unsafe.Pointer(cTransfer))
// 		ret9f964168 := sampleBlockCbFn9F964168Func(Transfer9f964168)
// 		ret, _ := (C.int)(ret9f964168), cgoAllocsUnknown
// 		return ret
// 	}
// 	panic("callback func has not been set (race?)")
// }

// var sampleBlockCbFn9F964168Func SampleBlockCbFn

// // packPCharString creates a Go string backed by *C.char and avoids copying.
// func packPCharString(p *C.char) (raw string) {
// 	if p != nil && *p != 0 {
// 		h := (*stringHeader)(unsafe.Pointer(&raw))
// 		h.Data = unsafe.Pointer(p)
// 		for *p != 0 {
// 			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
// 		}
// 		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
// 	}
// 	return
// }

// type stringHeader struct {
// 	Data unsafe.Pointer
// 	Len  int
// }

// // RawString reperesents a string backed by data on the C side.
// type RawString string

// // Copy returns a Go-managed copy of raw string.
// func (raw RawString) Copy() string {
// 	if len(raw) == 0 {
// 		return ""
// 	}
// 	h := (*stringHeader)(unsafe.Pointer(&raw))
// 	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
// }

// // unpackArgSDeviceList transforms a sliced Go data structure into plain C format.
// func unpackArgSDeviceList(x []DeviceList) (unpacked *C.hackrf_device_list_t, allocs *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	}
// 	allocs = new(cgoAllocMap)
// 	defer runtime.SetFinalizer(&unpacked, func(**C.hackrf_device_list_t) {
// 		go allocs.Free()
// 	})

// 	len0 := len(x)
// 	mem0 := allocDeviceListMemory(len0)
// 	allocs.Add(mem0)
// 	h0 := &sliceHeader{
// 		Data: mem0,
// 		Cap:  len0,
// 		Len:  len0,
// 	}
// 	v0 := *(*[]C.hackrf_device_list_t)(unsafe.Pointer(h0))
// 	for i0 := range x {
// 		allocs0 := new(cgoAllocMap)
// 		v0[i0], allocs0 = x[i0].PassValue()
// 		allocs.Borrow(allocs0)
// 	}
// 	h := (*sliceHeader)(unsafe.Pointer(&v0))
// 	unpacked = (*C.hackrf_device_list_t)(h.Data)
// 	return
// }

// // packSDeviceList reads sliced Go data structure out from plain C format.
// func packSDeviceList(v []DeviceList, ptr0 *C.hackrf_device_list_t) {
// 	const m = 0x7fffffff
// 	for i0 := range v {
// 		ptr1 := (*(*[m / sizeOfDeviceListValue]C.hackrf_device_list_t)(unsafe.Pointer(ptr0)))[i0]
// 		v[i0] = *NewDeviceListRef(unsafe.Pointer(&ptr1))
// 	}
// }

// // allocPDeviceMemory allocates memory for type *C.hackrf_device in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocPDeviceMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDeviceValue))
// 	if err != nil {
// 		panic("memory alloc error: " + err.Error())
// 	}
// 	return mem
// }

// const sizeOfPDeviceValue = unsafe.Sizeof([1]*C.hackrf_device{})

// // unpackArgSSDevice transforms a sliced Go data structure into plain C format.
// func unpackArgSSDevice(x [][]Device) (unpacked **C.hackrf_device, allocs *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	}
// 	allocs = new(cgoAllocMap)
// 	defer runtime.SetFinalizer(&unpacked, func(***C.hackrf_device) {
// 		go allocs.Free()
// 	})

// 	len0 := len(x)
// 	mem0 := allocPDeviceMemory(len0)
// 	allocs.Add(mem0)
// 	h0 := &sliceHeader{
// 		Data: mem0,
// 		Cap:  len0,
// 		Len:  len0,
// 	}
// 	v0 := *(*[]*C.hackrf_device)(unsafe.Pointer(h0))
// 	for i0 := range x {
// 		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
// 		v0[i0] = (*C.hackrf_device)(h.Data)
// 	}
// 	h := (*sliceHeader)(unsafe.Pointer(&v0))
// 	unpacked = (**C.hackrf_device)(h.Data)
// 	return
// }

// // packSSDevice reads sliced Go data structure out from plain C format.
// func packSSDevice(v [][]Device, ptr0 **C.hackrf_device) {
// 	const m = 0x7fffffff
// 	for i0 := range v {
// 		ptr1 := (*(*[m / sizeOfPtr]*C.hackrf_device)(unsafe.Pointer(ptr0)))[i0]
// 		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
// 		hxf0d18b7.Data = unsafe.Pointer(ptr1)
// 		hxf0d18b7.Cap = 0x7fffffff
// 		// hxf0d18b7.Len = ?
// 	}
// }

// // unpackPCharString represents the data from Go string as *C.char and avoids copying.
// func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
// 	h := (*stringHeader)(unsafe.Pointer(&str))
// 	return (*C.char)(h.Data), cgoAllocsUnknown
// }

// // unpackArgSReadPartidSerialno transforms a sliced Go data structure into plain C format.
// func unpackArgSReadPartidSerialno(x []ReadPartidSerialno) (unpacked *C.read_partid_serialno_t, allocs *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	}
// 	allocs = new(cgoAllocMap)
// 	defer runtime.SetFinalizer(&unpacked, func(**C.read_partid_serialno_t) {
// 		go allocs.Free()
// 	})

// 	len0 := len(x)
// 	mem0 := allocReadPartidSerialnoMemory(len0)
// 	allocs.Add(mem0)
// 	h0 := &sliceHeader{
// 		Data: mem0,
// 		Cap:  len0,
// 		Len:  len0,
// 	}
// 	v0 := *(*[]C.read_partid_serialno_t)(unsafe.Pointer(h0))
// 	for i0 := range x {
// 		allocs0 := new(cgoAllocMap)
// 		v0[i0], allocs0 = x[i0].PassValue()
// 		allocs.Borrow(allocs0)
// 	}
// 	h := (*sliceHeader)(unsafe.Pointer(&v0))
// 	unpacked = (*C.read_partid_serialno_t)(h.Data)
// 	return
// }

// // packSReadPartidSerialno reads sliced Go data structure out from plain C format.
// func packSReadPartidSerialno(v []ReadPartidSerialno, ptr0 *C.read_partid_serialno_t) {
// 	const m = 0x7fffffff
// 	for i0 := range v {
// 		ptr1 := (*(*[m / sizeOfReadPartidSerialnoValue]C.read_partid_serialno_t)(unsafe.Pointer(ptr0)))[i0]
// 		v[i0] = *NewReadPartidSerialnoRef(unsafe.Pointer(&ptr1))
// 	}
// }

// // unpackArgSOperacakeDwellTime transforms a sliced Go data structure into plain C format.
// func unpackArgSOperacakeDwellTime(x []OperacakeDwellTime) (unpacked *C.hackrf_operacake_dwell_time, allocs *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	}
// 	allocs = new(cgoAllocMap)
// 	defer runtime.SetFinalizer(&unpacked, func(**C.hackrf_operacake_dwell_time) {
// 		go allocs.Free()
// 	})

// 	len0 := len(x)
// 	mem0 := allocOperacakeDwellTimeMemory(len0)
// 	allocs.Add(mem0)
// 	h0 := &sliceHeader{
// 		Data: mem0,
// 		Cap:  len0,
// 		Len:  len0,
// 	}
// 	v0 := *(*[]C.hackrf_operacake_dwell_time)(unsafe.Pointer(h0))
// 	for i0 := range x {
// 		allocs0 := new(cgoAllocMap)
// 		v0[i0], allocs0 = x[i0].PassValue()
// 		allocs.Borrow(allocs0)
// 	}
// 	h := (*sliceHeader)(unsafe.Pointer(&v0))
// 	unpacked = (*C.hackrf_operacake_dwell_time)(h.Data)
// 	return
// }

// // packSOperacakeDwellTime reads sliced Go data structure out from plain C format.
// func packSOperacakeDwellTime(v []OperacakeDwellTime, ptr0 *C.hackrf_operacake_dwell_time) {
// 	const m = 0x7fffffff
// 	for i0 := range v {
// 		ptr1 := (*(*[m / sizeOfOperacakeDwellTimeValue]C.hackrf_operacake_dwell_time)(unsafe.Pointer(ptr0)))[i0]
// 		v[i0] = *NewOperacakeDwellTimeRef(unsafe.Pointer(&ptr1))
// 	}
// }

// // unpackArgSOperacakeFreqRange transforms a sliced Go data structure into plain C format.
// func unpackArgSOperacakeFreqRange(x []OperacakeFreqRange) (unpacked *C.hackrf_operacake_freq_range, allocs *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	}
// 	allocs = new(cgoAllocMap)
// 	defer runtime.SetFinalizer(&unpacked, func(**C.hackrf_operacake_freq_range) {
// 		go allocs.Free()
// 	})

// 	len0 := len(x)
// 	mem0 := allocOperacakeFreqRangeMemory(len0)
// 	allocs.Add(mem0)
// 	h0 := &sliceHeader{
// 		Data: mem0,
// 		Cap:  len0,
// 		Len:  len0,
// 	}
// 	v0 := *(*[]C.hackrf_operacake_freq_range)(unsafe.Pointer(h0))
// 	for i0 := range x {
// 		allocs0 := new(cgoAllocMap)
// 		v0[i0], allocs0 = x[i0].PassValue()
// 		allocs.Borrow(allocs0)
// 	}
// 	h := (*sliceHeader)(unsafe.Pointer(&v0))
// 	unpacked = (*C.hackrf_operacake_freq_range)(h.Data)
// 	return
// }

// // packSOperacakeFreqRange reads sliced Go data structure out from plain C format.
// func packSOperacakeFreqRange(v []OperacakeFreqRange, ptr0 *C.hackrf_operacake_freq_range) {
// 	const m = 0x7fffffff
// 	for i0 := range v {
// 		ptr1 := (*(*[m / sizeOfOperacakeFreqRangeValue]C.hackrf_operacake_freq_range)(unsafe.Pointer(ptr0)))[i0]
// 		v[i0] = *NewOperacakeFreqRangeRef(unsafe.Pointer(&ptr1))
// 	}
// }
